<#@ template  debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace ContentTypeTextNet.Pe.Library.Shared.Link.Model
{
<#
#>

    [Flags]
    public enum LogKind
    {
<# foreach(var logKindItem in logKindItems) { #>
        <#= logKindItem.Key #>,
<# } #>
    }

    public struct Caller
    {
        #region variable

        public readonly string memberName;
        public readonly string filePath;
        public readonly int lineNumber;

        #endregion

        public Caller(<#= callerArg #>)
        {
            this.memberName = callerMemberName;
            this.filePath = callerFilePath;
            this.lineNumber = callerLineNumber;
        }
    }

    public class LogItem
    {
        public LogItem(DateTime timestamp, LogKind kind, string message, string detail, Caller caller)
        {
            Timestamp = timestamp;
            Kind = kind;
            Message = message;
            Detail = detail;
            Caller = caller;
        }

        #region property

        public DateTime Timestamp { get; }
        public LogKind Kind { get; }
        public string Message { get; }
        public string Detail { get; }
        public Caller Caller { get; }

        public bool HasDetail => Detail != null;

        //TODO
        public string ShortFilePath => Caller.filePath;

        #endregion
    }

    public interface ILogFactory
    {
        ILogger CreateLogger(string header);
    }

    public interface ILoggerBase
    {
<# foreach(var logKindItem in logKindItems) { #>
        void <#= logKindItem.Key #>(string message, <#= callerArg #>);
        //void <#= logKindItem.Key #>(string message, string detail, <#= callerArg #>);
        void <#= logKindItem.Key #>(string message, object detail, <#= callerArg #>);
        void <#= logKindItem.Key #>(Exception exception, <#= callerArg #>);
<# } #>

        void Put(LogKind kind, string message, string detail, <#= callerArg #>);
    }

    public interface ILogger: ILoggerBase, ILogFactory
    {
        string Header { get; }
    }

    public abstract class LoggerBase : ILogger
    {
        public LoggerBase()
        { }

        public LoggerBase(string header)
        {
            CurrentHeader = header;
        }

        protected LoggerBase(string header, LoggerBase parentLogger)
        {
            CurrentHeader = header;
            ParentLogger = parentLogger;
        }

        public string Header
        {
            get
            {
                string separator = "/";

                if(ParentLogger == null) {
                    return separator;
                }

                if(ParentLogger.Header == separator) {
                    return separator + CurrentHeader;
                }

                return ParentLogger.Header + separator + CurrentHeader;
            }
        }
        protected LoggerBase ParentLogger { get; }
        protected string CurrentHeader { get; }

        protected abstract void PutCore(LogItem logItem);
        protected void Put(LogItem logItem)
        {
            if(ParentLogger != null) {
                ParentLogger.Put(logItem);
            } else {
                PutCore(logItem);
            }
        }
        protected abstract ILogger CreateLoggerCore(string header);

<# foreach(var logKindItem in logKindItems) { #>
        public void <#= logKindItem.Key #>(string message, <#= callerArg #>) => <#= PutMessage(logKindItem.Key) #>
        //public void <#= logKindItem.Key #>(string message, string detail, <#= callerArg #>) => <#= PutDetail(logKindItem.Key) #>
        public void <#= logKindItem.Key #>(string message, object detail, <#= callerArg #>) => <#= PutDetail(logKindItem.Key) #>
        public void <#= logKindItem.Key #>(Exception exception, <#= callerArg #>) => <#= PutException(logKindItem.Key) #>

<# } #>
        public void Put(LogKind kind, string message, string detail, <#= callerArg #>) => Put(new LogItem(DateTime.Now, kind, message, detail, <#= callerParam #>));

        #region ILogFactory

        public ILogger CreateLogger(string header) => CreateLoggerCore(header);

        #endregion
    }

    public sealed class NullLogger: LoggerBase
    {
        protected override void PutCore(LogItem logItem)
        { }

        protected override ILogger CreateLoggerCore(string header) => new NullLogger();
    }

    public sealed class ChildLogger: LoggerBase
    {
        public ChildLogger(string header, LoggerBase parentLogger)
            : base(header, parentLogger)
        { }

        protected override void PutCore(LogItem logItem)
        {
            throw new NotSupportedException();
        }

        protected override ILogger CreateLoggerCore(string header) => new ChildLogger(header, this);
    }

    public sealed class TestLogger : LoggerBase
    {
        public TestLogger()
            : base()
        { }

        protected override void PutCore(LogItem logItem)
        {
            var header = $"{DateTime.Now:yyyy-MM-ddTHH:mm:ss} {Header}[{logItem.Kind}] ";
            var headerIndent = new string(' ', header.Length);
            Console.WriteLine($"{header} {logItem.Message} <{logItem.Caller.memberName}>");
            if(logItem.HasDetail) {
                Console.WriteLine($"{headerIndent}{logItem.Detail}");
            }
            Console.WriteLine($"{headerIndent}{logItem.Caller.filePath}({logItem.Caller.lineNumber})");
        }

        protected override ILogger CreateLoggerCore(string header) => new ChildLogger(header, this);
    }

    public static class ILogFactoryExtensions
    {
        #region function

        public static ILogger CreateCurrentClass(this ILogFactory logFactory)
        {
            return logFactory.CreateLogger(new StackFrame(1).GetMethod().DeclaringType.Name);
        }

        #endregion
    }

}

<#+
    class LogKindItem
    {
        public string Key { get; set; }
    }
    IEnumerable<LogKindItem> logKindItems = new [] {
        new LogKindItem() { Key = "Trace", },
        new LogKindItem() { Key = "Debug", },
        new LogKindItem() { Key = "Information", },
        new LogKindItem() { Key = "Warning", },
        new LogKindItem() { Key = "Error", },
        new LogKindItem() { Key = "Fatal", },
    };

    string callerArg = "[CallerLineNumber] int callerLineNumber = 0, [CallerFilePath] string callerFilePath = \"\", [CallerMemberName] string callerMemberName = \"\"";
    string callerParam = "new Caller(callerLineNumber, callerFilePath, callerMemberName)";

    string PutMessage(string kind) {
        return "Put(new LogItem(DateTime.Now, LogKind." + kind + ", message, null, " + callerParam + "));";
    }
    string PutDetail(string kind) {
        return "Put(new LogItem(DateTime.Now, LogKind." + kind + ", message, detail?.ToString(), " + callerParam + "));";
    }
    string PutException(string kind) {
        return "Put(new LogItem(DateTime.Now, LogKind." + kind + ", exception.Message, exception.ToString(), " + callerParam + "));";
    }
#>
