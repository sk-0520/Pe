<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output encoding="utf-8" extension="" #>
<#
    var items = new[] {
        "int8_t",
        "uint8_t",
        "int16_t",
        "uint16_t",
        "int32_t",
        "uint32_t",
        "TCHAR",
    }.Select(i => new {
        ValueType = i,
        BaseName = i.Replace("_t", string.Empty).ToLowerInvariant()
    }).Select(i => new {
        ValueType = i.ValueType,
        BaseName = i.BaseName,
        TypeName = "PRIMITIVE_LIST_TYPE_" + i.BaseName.ToUpperInvariant(),
        AliasList = "PRIMITIVE_LIST_" + i.BaseName.ToUpperInvariant(),
    });
#>
#include "list.h"
#include "memory.h"
#include "debug.h"

/// <summary>
/// 指定型のバイト幅を取得。
/// </summary>
/// <param name="list_type"></param>
/// <returns></returns>
static size_t get_type_byte(PRIMITIVE_LIST_TYPE list_type)
{
    switch (list_type) {
<# foreach(var item in items) { #>
        case <#= item.TypeName #>:
            return sizeof(<#= item.ValueType #>);
<# } #>
        default:
            assert_debug(false);
    }

    return 0;
}

/// <summary>
/// 指定型の長さをバイト単位で取得。
/// </summary>
/// <param name="list_type"></param>
/// <param name="length"></param>
/// <returns></returns>
static size_t get_type_bytes(PRIMITIVE_LIST_TYPE list_type, size_t length)
{
    if (!length) {
        return 0;
    }
    return get_type_byte(list_type) * length;
}

PRIMITIVE_LIST RC_HEAP_FUNC(new_primitive_list, PRIMITIVE_LIST_TYPE list_type, size_t capacity)
{
    size_t capacity_bytes = get_type_bytes(list_type, capacity);
    void* buffer = RC_HEAP_CALL(allocate_memory, capacity_bytes, false);

    PRIMITIVE_LIST result = {
        .buffer = buffer,
        .length = 0,
        .library = {
            .capacity_bytes = capacity_bytes,
            .type = list_type,
        },
    };

    return result;
}

bool RC_HEAP_FUNC(free_primitive_list, PRIMITIVE_LIST* list)
{
    if (!list) {
        return false;
    }
    if (!list->buffer) {
        return false;
    }

    return RC_HEAP_CALL(free_memory, list->buffer);
}

// 同じような処理ばっか書いてんね
static size_t extend_capacity_if_not_enough_list(PRIMITIVE_LIST* list, size_t need_length)
{
    size_t need_bytes = get_type_bytes(list->library.type, need_length);
    size_t current_bytes = get_type_bytes(list->library.type, list->length);
    // まだ大丈夫なら何もしない
    size_t need_total_bytes = current_bytes + need_bytes;
    if (need_total_bytes <= list->library.capacity_bytes) {
        return 0;
    }

    size_t old_capacity_bytes = list->library.capacity_bytes;
    size_t new_capacity_bytes = list->library.capacity_bytes;
    do {
        new_capacity_bytes *= 2;
    } while (new_capacity_bytes < need_total_bytes);

    void* new_buffer = allocate_memory(new_capacity_bytes, false);
    void* old_buffer = list->buffer;

    copy_memory(new_buffer, old_buffer, new_capacity_bytes);
    free_memory(old_buffer);

    list->buffer = new_buffer;
    list->library.capacity_bytes = new_capacity_bytes;

    return new_capacity_bytes - old_capacity_bytes;
}

<# foreach(var item in items) { #>
bool push_list_<#= item.BaseName #>(<#= item.AliasList #>* list, <#= item.ValueType #> value)
{
    if(list->library.type != <#= item.TypeName #>) {
        return false;
    }

    extend_capacity_if_not_enough_list(list, 1);

    <#= item.ValueType #>* buffer = (<#= item.ValueType #>*)list->buffer;
    buffer[list->length++] = value;

    return true;
}
<# } #>

<# foreach(var item in items) { #>
bool pop_list_<#= item.BaseName #>(<#= item.ValueType #>* result, <#= item.AliasList #>* list)
{
    if(list->library.type != <#= item.TypeName #>) {
        return false;
    }

    if(!list->length) {
        return false;
    }

    if(result) {
        <#= item.ValueType #>* buffer = (<#= item.ValueType #>*)list->buffer;
        *result = buffer[--list->length];
    } else {
        list->length -= 1;
    }

    return true;
}
<# } #>

<# foreach(var item in items) { #>
bool get_list_<#= item.BaseName #>(<#= item.ValueType #>* result, <#= item.AliasList #>* list, size_t index)
{
    if(list->library.type != <#= item.TypeName #>) {
        return false;
    }

    if(index < list->length) {
        <#= item.ValueType #>* buffer = (<#= item.ValueType #>*)list->buffer;
        *result = buffer[index];
        return true;
    }

    return false;
}
<# } #>

<# foreach(var item in items) { #>
<#= item.ValueType #>* reference_list_<#= item.BaseName #>(<#= item.AliasList #>* list)
{
    if(list->library.type != <#= item.TypeName #>) {
        return NULL;
    }

    return (<#= item.ValueType #>*)list->buffer;
}
<# } #>

