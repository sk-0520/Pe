<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#+

class TokenDefine
{
    public TokenDefine(string line)
    {
        var tsv = line.Split('\t');
        var index = 0;
        Group = tsv[index++];
        Sub = tsv[index++];
        Key = tsv[index++];
        Implement = bool.Parse(tsv[index++]);
        CommentDelimiter = bool.Parse(tsv[index++]);
        Value = tsv[index++];
        Comment = tsv[index++];
    }

    #region property

    public string Group { get; }
    public string Sub { get; }
    public string Key { get; }
    public bool Implement { get; }
    public bool CommentDelimiter { get; }
    public string Value { get; }
    public string Comment { get; }

    public bool IsOperator { get { return Group == "op"; } }
    public bool IsBracket { get { return Group == "bracket"; } }
    public bool IsComment { get { return Group == "comment"; } }
    public bool IsBlockComment { get { return IsComment && Sub == "block"; } }
    public bool IsLiteral { get { return Group == "literal"; } }
    public bool IsKeyword { get { return Group == "keyword"; } }
    public bool IsTypeKeyword { get { return IsKeyword && Sub == "type"; } }

    #endregion

    #region function

    private string EscapeSequenceCharacter(char c)
    {
        var escseq = new [] { '\'', '\\', };
        if(Array.IndexOf(escseq, c) != -1) {
            return "\\" + c.ToString();
        }

        return c.ToString();
    }

    public string ToSingleSymbolCharacter()
    {
        if(Value.Length != 1) {
            throw new InvalidOperationException();
        }

        return EscapeSequenceCharacter(Value[0]);
    }

    public IEnumerable<string> ToMultiSymbolCharacters()
    {
        if(Value.Length <= 1) {
            throw new InvalidOperationException();
        }

        return Value.Select(i => EscapeSequenceCharacter(i));
    }


    #endregion
}

static class TokenLoader
{
    #region function

    public static IEnumerable<TokenDefine> ParseFromDefault(ITextTemplatingEngineHost host)
    {
        var definePath = host.ResolvePath(@"..\..\..\Define\script-token.def");
        var defineLines = File.ReadAllLines(definePath).Skip(1);
        return Parse(defineLines);
    }

    public static IEnumerable<TokenDefine> Parse(IEnumerable<string> source)
    {
        return source.Select(i => new TokenDefine(i));
    }

    #endregion
}

static class TokenUtility
{
    #region property

    public const int IndentWidth = 4;
    public const char IndentCharacter = ' ';

    public const string TokenKind = "TOKEN_KIND";

    public static string None
    {
        get { return ToDefineKind("none"); }
    }
    public static string Word
    {
        get { return ToDefineKind("word"); }
    }

    #endregion

    #region function

    public static bool IsToken(string s)
    {
        return s.ToUpperInvariant().StartsWith(TokenKind + "_");
    }


    public static string ToDefineKind(string s)
    {
        return TokenKind + "_" + s.ToUpperInvariant();
    }

    public static string ToDefineKind(TokenDefine define, int indent, bool withComment)
    {
        var results = new List<string>();

        if(withComment) {
            results.Add("/// <summary>");
            results.Add("/// " + define.Comment);
            if(!define.Implement) {
                results.Add("/// <para>未実装</para>");
            }
            results.Add("/// </summary>");
        }
        var values = new [] {
            define.Group,
            define.Sub,
            define.Key,
        };
        var value = string.Join("_", values.Where(i => !string.IsNullOrWhiteSpace(i)));
        results.Add(ToDefineKind(value));

        return string.Join(Environment.NewLine, results.Select(i => new string(IndentCharacter, indent * IndentWidth) + i));
    }

    #endregion
}

#>
