<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output encoding="utf-8" extension="" #>
<#
    var items = SyntaxLoader.ParseFromDefault(Host).ToList();
#>
/* 自動生成: syntax_analyzer.z.default_parse.c.tt */
#include "../Pe.Library/debug.h"
#include "../Pe.Library/logging.h"
#include "../Pe.Library/memory.h"

#include "syntax_analyzer.z.default_parse.h"

#define DEFAULT_SYNTAX_DEFINE_LENGTH (<#= items.Count #>)

static const TEXT script__syntax_define_kind_member_names[] = {
<# foreach(var item in items) { #>
    static_text("<#= SyntaxUtility.ToDefineKind(item, 0, false) #>"),
<# } #>
};

const TEXT* get_member_name_by_syntax_define_kind(<#= SyntaxUtility.DefineKind #> syntax_define_kind)
{
    assert(syntax_define_kind < SIZEOF_ARRAY(script__syntax_define_kind_member_names));

    return script__syntax_define_kind_member_names + syntax_define_kind;
}

SYNTAXES new_default_syntaxes(void)
{
    const MEMORY_RESOURCE* memory_resource = SCRIPT_MEMORY;
    SYNTAX_DEFINE* syntax_defines = new_memory(DEFAULT_SYNTAX_DEFINE_LENGTH, sizeof(SYNTAX_DEFINE), memory_resource);

    SYNTAXES result = {
        .defines = syntax_defines,
        .length = DEFAULT_SYNTAX_DEFINE_LENGTH,
        .script = {
            .memory_resource = memory_resource,
        },
    };

<# for(var i = 0; i < items.Count; i++) { #>
<#
    var item = items[i];
    var defineName = "define_" + i + "_" + item.Key;
#>
    SYNTAX_DEFINE <#= defineName #> = {
        .kind = <#= SyntaxUtility.ToDefineKind(item, 0, false) #>,
        .elements = allocate_raw_memory(sizeof(SYNTAX_ELEMENTS) * <#= item.Elements.Count #>, false, memory_resource),
        .length = <#= item.Elements.Count #>,
    };
<# for(var j = 0; j < item.Elements.Count; j++) { #>
<#
       var element = item.Elements[j];
#>
    <#= defineName #>.elements[<#= j #>].data = allocate_raw_memory(sizeof(SYNTAX_ELEMENT) * <#= element.Data.Count #>, false, memory_resource),
    <#= defineName #>.elements[<#= j #>].length = <#= element.Data.Count #>;
<# for(var k = 0; k < element.Data.Count; k++) { #>
<#
    var data = element.Data[k];
    var dataName = defineName + "_element_" + j + "_data_" + k;
    string rule;
    string dataItem = data;
    if(SyntaxUtility.Rules.TryGetValue(data.Substring(data.Length - 1), out rule)) {
        dataItem = data.Substring(0, data.Length - 1);
    } else {
        rule = SyntaxUtility.Rules[string.Empty];
    }
    var isToken = TokenUtility.IsToken(dataItem);
    var type = isToken ? "SYNTAX_ELEMENT_TYPE_TOKEN": "SYNTAX_ELEMENT_TYPE_DEFINE";
#>
    SYNTAX_ELEMENT <#= dataName #>_value = {
        .rule = <#= rule #>,
        .type = <#= type #>,
        .item = {
<# if(isToken) { #>
            .token = <#= dataItem #>,
<# } else { #>
            .define = <#= SyntaxUtility.ToDefineKind(dataItem) #>,
<# } #>
        }
    };
    <#= defineName #>.elements[<#= j #>].data[<#= k #>] = <#= dataName #>_value;

<# } #>
<# } #>
<# } #>

<# for(var i = 0; i < items.Count; i++) { #>
<#
    var item = items[i];
    var defineName = "define_" + i + "_" + item.Key;
#>
    syntax_defines[<#= i #>] = <#= defineName #>;
<# } #>

    return result;
}

void release_syntaxes(SYNTAXES* syntaxes)
{
    const MEMORY_RESOURCE* memory_resource = syntaxes->script.memory_resource;

    for (size_t i = 0; i < syntaxes->length; i++) {
        for (size_t j = 0; j < syntaxes->defines[i].length; j++) {
            release_memory(syntaxes->defines[i].elements[j].data, memory_resource);
        }
        release_memory(syntaxes->defines[i].elements, memory_resource);
    }
    release_memory(syntaxes->defines, memory_resource);
    set_memory(syntaxes, sizeof(SYNTAXES), 0);
}

<#@ include file="lexical_token.ttinclude" once="true" #>
<#@ include file="syntax_analyzer.syntax.ttinclude" once="true" #>
