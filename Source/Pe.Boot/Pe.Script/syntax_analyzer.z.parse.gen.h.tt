<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output encoding="utf-8" extension="" #>
<#
    var items = SyntaxLoader.ParseFromDefault(Host).ToList();
#>
#pragma once
/* 自動生成: syntax_analyzer.z.default_parse.gen.h.tt */
#include "lexical_analyzer.h"
#include "lexical_analyzer.z.token.h"

/// <summary>
/// 構文定義種別。
/// </summary>
typedef enum tag_<#= SyntaxUtility.DefineKind #>
{
    /// <summary>
    /// なし。
    /// <para>番兵にでも使うかなぁ</para>
    /// </summary>
    <#= SyntaxUtility.ToDefineKind("NONE") #>,
<# foreach(var item in items) { #>
<#= SyntaxUtility.ToDefineKind(item, 1, true) #>,
<# } #>
} <#= SyntaxUtility.DefineKind #>;

/// <summary>
/// 構文要素タイプ。
/// </summary>
typedef enum tag_SYNTAX_ELEMENT_TYPE
{
    /// <summary>
    /// トークン。
    /// </summary>
    SYNTAX_ELEMENT_TYPE_TOKEN,
    /// <summary>
    /// 構文定義。
    /// </summary>
    SYNTAX_ELEMENT_TYPE_DEFINE,
    /// <summary>
    /// 要素(再帰的に使用),
    /// </summary>
    SYNTAX_ELEMENT_TYPE_ELEMENTS, // これいる？
} SYNTAX_ELEMENT_TYPE;

typedef enum tag_SYNTAX_RULE
{
    /// <summary>
    /// 通常。
    /// </summary>
    SYNTAX_RULE_NORMAL,
    /// <summary>
    /// 0個以上。*
    /// </summary>
    SYNTAX_RULE_MORE_0,
    /// <summary>
    /// 1個以上。+
    /// </summary>
    SYNTAX_RULE_MORE_1,
    /// <summary>
    /// 省略可能。?
    /// </summary>
    SYNTAX_RULE_OPTION,
} SYNTAX_RULE;

struct tag_SYNTAX_ELEMENTS;

/// <summary>
/// 構文要素。
/// </summary>
typedef struct tag_SYNTAX_ELEMENT
{
    /// <summary>
    /// 構文要素タイプ。
    /// </summary>
    SYNTAX_ELEMENT_TYPE type;
    /// <summary>
    /// 構文ルール。
    /// </summary>
    SYNTAX_RULE rule;
    union
    {
        SYNTAX_DEFINE_KIND define;
        TOKEN_KIND token;
        /// <summary>
        /// 再帰的要素
        /// </summary>
        struct tag_SYNTAX_ELEMENTS* elements; // これいる？
    } item;
} SYNTAX_ELEMENT;

typedef struct tag_SYNTAX_ELEMENTS
{
    SYNTAX_ELEMENT* data; // 自動生成作って動的にする想定
    size_t length;
} SYNTAX_ELEMENTS;

typedef struct tag_SYNTAX_DEFINE
{
    SYNTAX_DEFINE_KIND kind;
    SYNTAX_ELEMENTS* elements;
    size_t length;
} SYNTAX_DEFINE;

typedef struct tag_SYNTAXES
{
    SYNTAX_DEFINE* defines;
    size_t length;
    struct
    {
        const MEMORY_ARENA_RESOURCE* memory_resource;
    } script;
} SYNTAXES;

const TEXT* get_member_name_by_syntax_define_kind(<#= SyntaxUtility.DefineKind #> syntax_define_kind);

SYNTAXES new_default_syntaxes(void);

<#@ include file="syntax_analyzer.syntax.t4" once="true" #>
