<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output encoding="utf-8" extension="" #>
<#
    var items = SyntaxLoader.ParseFromDefault(Host).ToList();
#>
/* 自動生成: syntax_analyzer.z.parse.c.tt */
#include "../Pe.Library/debug.h"
#include "../Pe.Library/logging.h"
#include "../Pe.Library/memory.h"

#include "syntax_analyzer.z.parse.h"

SYNTAX_DEFINE script__syntax_defines[SYNTAX_DEFINE_LENGTH];
static bool script__initialized_syntax_defines = false;

void script__initialize_syntax_defines(void)
{
<# for(var i = 0; i < items.Count; i++) { #>
<#
    var item = items[i];
    var defineName = "define_" + i + "_" + item.Key;
#>
    SYNTAX_DEFINE <#= defineName #> = {
        .kind = <#= SyntaxUtility.ToDefineKind(item, 0, false) #>,
        .elements = allocate_memory(sizeof(SYNTAX_ELEMENTS) * <#= item.Elements.Count #>, false),
        .length = <#= item.Elements.Count #>,
    };
<# for(var j = 0; j < item.Elements.Count; j++) { #>
<#
       var element = item.Elements[j];
#>
    <#= defineName #>.elements[<#= j #>].data = allocate_memory(sizeof(SYNTAX_ELEMENT) * <#= element.Data.Count #>, false),
    <#= defineName #>.elements[<#= j #>].length = <#= element.Data.Count #>;
<# for(var k = 0; k < element.Data.Count; k++) { #>
<#
    var data = element.Data[k];
    var dataName = defineName + "_element_" + j + "_data_" + k;
    string rule;
    string dataItem = data;
    if(SyntaxUtility.Rules.TryGetValue(data.Substring(data.Length - 1), out rule)) {
        dataItem = data.Substring(0, data.Length - 1);
    } else {
        rule = SyntaxUtility.Rules[string.Empty];
    }
    var isToken = SyntaxUtility.IsTokenKind(dataItem);
    var type = isToken ? "SYNTAX_ELEMENT_TYPE_TOKEN": "SYNTAX_ELEMENT_TYPE_DEFINE";
#>
    SYNTAX_ELEMENT <#= dataName #>_value = {
        .rule = <#= rule #>,
        .type = <#= type #>,
        .item = {
<# if(isToken) { #>
            .token = <#= dataItem #>,
<# } else { #>
            .define = <#= SyntaxUtility.ToDefineKind(dataItem) #>,
<# } #>
        }
    };
    <#= defineName #>.elements[<#= j #>].data[<#= k #>] = <#= dataName #>_value;

<# } #>
<# } #>
<# } #>

<# for(var i = 0; i < items.Count; i++) { #>
<#
    var item = items[i];
    var defineName = "define_" + i + "_" + item.Key;
#>
    script__syntax_defines[<#= i #>] = <#= defineName #>;
<# } #>
    script__initialized_syntax_defines = true;
}

void script__uninitialize_syntax_defines(void)
{
    if (!script__initialized_syntax_defines) {
        return;
    }

    for (size_t i = 0; i < SYNTAX_DEFINE_LENGTH; i++) {
        for (size_t j = 0; j < script__syntax_defines[i].length; j++) {
            free_memory(script__syntax_defines[i].elements[j].data);
        }
        free_memory(script__syntax_defines[i].elements);
    }

    script__initialized_syntax_defines = false;
}

<#@ include file="syntax_analyzer.syntax.ttinclude" once="true" #>
